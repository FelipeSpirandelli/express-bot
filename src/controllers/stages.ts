import Update, { User } from '../models/Update'
import apiVtex from '../services/vtex/api'
import formatPrice from '../utils/formatPrice'
import truncateText from '../utils/truncateText'
import bot from './bot'
import users from './users'
import usersInfo from './usersInfo'

const stages =
{
	welcome: async (text: string, update: Update, user: User) =>
	{
		await users.start(update)
		let name = await usersInfo.getName(user.id)
		
		if (!name)
		{
			await usersInfo.setName(user.id, 'tmp')
			return await bot.sendMessage(update,
				'Ol√° üôãüèª‚Äç‚ôÄÔ∏è, meu nome √© Tha√≠s e estou aqui para te ajudar a fazer compras. üõíüõçÔ∏è' +
				'\nAntes de come√ßarmos qual o seu nome? üòÅ'
			)
		}
		else
		{
			if (name === 'tmp')
			{
				await usersInfo.setName(user.id, text)
				name = text
			}

			const hasPreviousCart = await usersInfo.hasPreviousCart(user.id)

			await users.nextStage(user)

			await bot.sendMessage(update,
				`Que bom te ver por aqui, ${name}!` +
				'\n\n‚ö†Ô∏è Algumas orienta√ß√µes para nos ajudar nesta compra:' +
				'\n- Conversaremos s√≥ por mensagens;' +
				'\n- Digite o nome do produto que voc√™ deseja comprar;' +
				'\n- Clique em "selecionar" para adicionar seu produto no carrinho;' +
				'\n- N√£o se esque√ßa de conferir nossas promo√ß√µes di√°rias.'
			)
	
			await bot.sendMessage(update,
				'Ent√£o vamos l√°!' +
				'\nDiga-me o nome do produto que voc√™ quer pesquisar.',
				hasPreviousCart
					? [[
						{label: 'Repetir √∫ltima compra', command: '/ultima'}
					]]
					: undefined
			)
		}
	},

	selectProducts: async (text: string, update: Update, user: User) =>
	{
		const isUserSelectingQuantity = await users.isUserSelectingQuantity(user)

		if (!isUserSelectingQuantity.answer)
		{
			if (text === '/finalizar')
			{
				const cart = await users.getCart(user)
				
				if (cart.length === 0)
					await bot.sendMessage(update,
						'O seu carrinho est√° vazio!' +
						'\nSe foi um engano, voc√™ pode pesquisar por outro produto.',
						[[
							{label: 'Cancelar pedido', command: '/cancelar'}
						]]
					)
				else
				{
					users.nextStage(user)

					await bot.sendMessage(update,
						'Pedido finalizado com sucesso!' +
						'\nAgora, vamos cuidar das informa√ß√µes financeiras... üí∞'
					)

					bot.sendPayment(update, cart)
				}
			}
			else if (text === '/cancelar')
			{
				users.remove(user)

				await bot.sendMessage(update,
					'Poxa... Que pena! Seu pedido foi cancelado com sucesso!' +
					'\n\nü§ó Espero te ver por aqui em breve!!!'
				)
			}
			else if (text === '/ultima')
			{
				const cart = await usersInfo.getPreviousCart(user.id)
				await users.setCart(user.id, cart)

				const cartDisplay = await users.getCartDisplay(user)
				await bot.sendMessage(update, cartDisplay)

				await bot.sendMessage(update,
					'Seu carrinho est√° enchendo! üõçÔ∏è' +
					'\nDiga-me qual outro produto voc√™ deseja.' +
					'\nSe for s√≥ isso mesmo, podemos finalizar a compra.',
					[[{
						label: 'Finalizar',
						command: '/finalizar'
					}]]
				)
			}
			else if (['/selecionar', '/editar'].includes(text.split('_')[0]))
			{
				const productId = Number(text.split('_')[1])
				const product = apiVtex.getProduct(productId)

				if (!product)
				{
					bot.sendMessage(update,
						'‚ö†Ô∏è N√£o encontrei nenhum produto com esse nome! Vamos tentar outro produto? ‚ö†Ô∏è'
					)
				}
				else
				{
					await users.toggleIsUserSelectingQuantity(user, productId)

					bot.sendMessage(update,
						`${text.split('_')[0] === '/editar' ? 'Mudou de ideia? ' : ''}` +
						`Qual a quantidade que voc√™ deseja comprar de ${product.name}? ü§î` +
						'\n\nOBS.: Digite somente n√∫meros maiores que 0',
						[[{
							label: 'Cancelar',
							command: '/cancelar'
						}]]
					)
				}
			}
			else if (text.split('_')[0] === '/remover')
			{
				const productId = Number(text.split('_')[1])
				await users.removeProduct(user, productId)

				const cartDisplay = await users.getCartDisplay(user)
				await bot.sendMessage(update, cartDisplay)

				await bot.sendMessage(update,
					'Produto removido com sucesso!' +
					'\nDiga-me o nome de mais um produto que voc√™ deseja pesquisar.',
					[[{
						label: 'Finalizar',
						command: '/finalizar'
					}]]
				)
			}
			else if (text.split('_')[0] === '/imagem')
			{
				const productId = Number(text.split('_')[1])
				const product = apiVtex.getProduct(productId)

				if (!product)
					return await bot.sendMessage(update, 
						'‚ö†Ô∏è N√£o encontrei nenhum produto com esse nome! Vamos tentar outro produto? ‚ö†Ô∏è',
						[[{
							label: 'Finalizar',
							command: '/finalizar'
						}]]
					)
				
				bot.sendImage(update,
					product.image,
					product.name,
					[[
						{text: 'Selecionar produto', callback_data: `/selecionar_${product.id}`}
					]]
				)
			}
			else
			{
				const search = text.trim()
				const products = apiVtex.searchProducts(search)

				if (products.length === 0)
					return bot.sendMessage(update, 
						'‚ö†Ô∏è N√£o encontrei nenhum produto com esse nome! Vamos tentar outro produto? ‚ö†Ô∏è',
						[[{
							label: 'Finalizar',
							command: '/finalizar'
						}]]
					)

				const productsDisplay = products.map((product) => (
					`\n\n‚û°Ô∏è <b>${product.name}</b>` +
					`\n${formatPrice(product.price)}` +
					`\n${truncateText(product.description, 100)}` +
					`\n<code>Selecionar aqui:</code> /selecionar_${product.id}` +
					`\n<code>Ver imagem aqui:</code> /imagem_${product.id}`
				))

				await bot.sendSearchPaginated(update,
					`Mostrando ${productsDisplay.length} resultados de produtos...`,
					productsDisplay,
					search
				)

				bot.sendMessage(update,
					'Se voc√™ quiser pesquisar por outro produto, basta digitar que eu cuido disso para voc√™.',
					[[{
						label: 'Finalizar',
						command: '/finalizar'
					}]]
				)
			}
		}
		else
		{
			const product = isUserSelectingQuantity.product
			if (!product)
				return

			if (text === '/cancelar')
			{
				await users.toggleIsUserSelectingQuantity(user)

				return bot.sendMessage(update,
					'Pronto... J√° cancelei!' +
					'\nSe voc√™ quiser pesquisar por outro produto, basta digitar que eu cuido disso para voc√™.',
					[[{
						label: 'Finalizar',
						command: '/finalizar'
					}]]
				)
			}

			const quantity = Math.round(Number(text))

			if (isNaN(quantity) || quantity < 1)
				return bot.sendMessage(update,
					'Voc√™ me mandou uma quantidade inv√°lida! Vamos tentar novamente...' +
					`\nQual a quantidade que voc√™ deseja comprar de ${product.name}? ü§î` +
					'\n\nOBS.: Digite somente n√∫meros maiores que 0',
					[[{
						label: 'Cancelar',
						command: '/cancelar'
					}]]
				)

			await users.addProduct(user, product, quantity)
			await users.toggleIsUserSelectingQuantity(user)
			
			const cartDisplay = await users.getCartDisplay(user)
			await bot.sendMessage(update, cartDisplay)

			return bot.sendMessage(update,
				'Seu carrinho est√° enchendo! üõçÔ∏è' +
				'\nDiga-me qual outro produto voc√™ deseja.' +
				'\nSe for s√≥ isso mesmo, podemos finalizar a compra.',
				[[{
					label: 'Finalizar',
					command: '/finalizar'
				}]]
			)
		}
	},

	checkout: async (text: string, update: Update, user: User) =>
	{
		if (text === '/cancelar')
		{
			users.remove(user)

			return await bot.sendMessage(update,
				'Poxa... Que pena! Seu pedido foi cancelado com sucesso!' +
				'\n\nü§ó Espero te ver por aqui em breve!!!'
			)
		}
		else if (text === '/payed')
		{
			const cart = await users.getCart(user)
			usersInfo.setPreviousCart(user.id, cart)

			users.remove(user)

			const cep = update.shipping_query
				? update.shipping_query.shipping_address.post_code
				: ''
			apiVtex.sendOrder(cep, cart)

			return await bot.sendMessage(update,
				'Pedido confirmado com sucesso!' +
				'\n\nü§ó Obrigado por comprar conosco! Volte sempre!!!',
				[[{
					label: 'Visitar nosso site',
					command: 'filler',
					url: 'https://www.avon.com.br/'
				}]]
			)
		}
		else
		{
			await bot.sendMessage(update,
				'Opera√ß√£o inv√°lida!' +
				'\nVoc√™ precisa selecionar uma das op√ß√µes abaixo. üòâ'
			)

			const cart = await users.getCart(user)
			await bot.sendPayment(update, cart)
		}
	}
}

export default stages